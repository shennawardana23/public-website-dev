import{_ as t,c as o,a0 as a,o as n}from"./chunks/framework.CGHvQLJz.js";const h=JSON.parse('{"title":"Guidelines and Basic Concepts of Programming","description":"","frontmatter":{},"headers":[],"relativePath":"guide/programming-concepts.md","filePath":"guide/programming-concepts.md"}'),i={name:"guide/programming-concepts.md"};function s(r,e,c,l,d,m){return n(),o("div",null,e[0]||(e[0]=[a('<h1 id="guidelines-and-basic-concepts-of-programming" tabindex="-1"><img src="https://media.giphy.com/media/VgCDAzcKvsR6OM0uWg/giphy.gif" width="50"> Guidelines and Basic Concepts of Programming <a class="header-anchor" href="#guidelines-and-basic-concepts-of-programming" aria-label="Permalink to &quot;&lt;img src=&quot;https://media.giphy.com/media/VgCDAzcKvsR6OM0uWg/giphy.gif&quot; width=&quot;50&quot;&gt;  Guidelines and Basic Concepts of Programming&quot;">​</a></h1><p><a href="./en-README.html">Back to Home</a></p><p>This section contains a summary and basic references for programming for Arch Public Website Developer.</p><hr><h3 id="clean-code" tabindex="-1">Clean Code <a class="header-anchor" href="#clean-code" aria-label="Permalink to &quot;Clean Code&quot;">​</a></h3><p>The concept of <em>Clean Code</em> has several interpretations and characteristics, including:</p><ul><li><p><strong>The code must be easy to understand</strong></p></li><li><p>Have a clear and consistent workflow/data exchange</p></li><li><p>Collaboration between <em>classes</em> or files must be easy to understand</p></li><li><p>The responsibilities and functions of each file must be easy to understand. Don&#39;t create functions that are too complex if they are not needed.</p></li><li><p>The functions or <em>methods</em> contained in a file must be easy to understand</p></li><li><p>The purpose, naming and function of each variable or line is easy to understand and easy to read</p></li><li><p>The code must be easy to read, add comments in parts that are quite complex or less stable (see the <em>readable code</em> section)</p></li><li><p><strong>The code must be easy to change</strong></p></li><li><p>Classes and functions must be kept small and responsible for a particular job (<em>single responsibility principle</em>)</p></li><li><p>Classes should have a clear API and be easy to understand / easy to read</p></li><li><p>Classes and their functions must work as they should and the processes within them are easy to predict</p></li><li><p>Has a <em>unit test</em> or is arranged in such a way as to make it easier to create tests.</p></li><li><p>The available tests are easy to understand and easy to change</p></li><li><p>Code redundancy must be kept to a minimum (<em>DRY principle</em>) so that the code can continue to run consistently when changes occur somewhere</p></li><li><p>Dependencies in the code must be kept to a minimum to reduce the risk of errors due to changing dependencies</p></li></ul><blockquote><p>&quot;Clean Code is a code that is written by someone who cares&quot; - <strong>Michael Feathers</strong></p></blockquote><p>Read more:</p><p><a href="https://drive.google.com/drive/u/0/folders/1NFAgCa7aAdRPFsxBy2RC7Sjhx4tSYfPP" target="_blank" rel="noreferrer">Clean Code : A Handbook of Agile Software Craftsmanship</a></p><p><a href="https://drive.google.com/drive/u/0/folders/1NFAgCa7aAdRPFsxBy2RC7Sjhx4tSYfPP" target="_blank" rel="noreferrer">High Quality Code for Better Programmers</a></p><hr><h3 id="readable-code-concept" tabindex="-1">Readable Code Concept <a class="header-anchor" href="#readable-code-concept" aria-label="Permalink to &quot;Readable Code Concept&quot;">​</a></h3><p>What developers quite often forget is that the code they develop will be reused someday, perhaps by someone else. Many cases arise when old code is reopened, it takes time to understand or remember how the code was created. This time can be minimized if the code is easy to read and understand.</p><p>The principles for creating easy-to-read code are:</p><ul><li>Consistency in code creation procedures, including:</li><li>Spaces vs tabs</li><li>Placement</li><li>Follow the agreements that apply within the team</li><li>Consistent naming of <em>files &amp; folders</em>:</li><li>Place files in <em>folders</em> that are relevant and easy to understand</li><li>Naming conventions (CamelCase, snake-case, etc)</li><li>Follow the agreements that apply within the team</li><li>Insert comments and documentation in places that require additional explanation</li><li>Avoid creating functions/lines that are complex and require additional time to understand.</li><li>Avoid spaces / tabs that are too indented (<em>deep nesting</em>) because it will make it difficult to understand the function and purpose of the code</li></ul><blockquote><p>&quot;Always code as if the person who ends up maintaining your code is a violent psychopath who knows where you live. Code for readability&quot; - <strong>John F Woods</strong></p></blockquote><p>Read more:</p><p><a href="https://drive.google.com/drive/u/0/folders/1NFAgCa7aAdRPFsxBy2RC7Sjhx4tSYfPP" target="_blank" rel="noreferrer">The Art of Readable Code</a></p><p><a href="https://drive.google.com/drive/u/0/folders/1NFAgCa7aAdRPFsxBy2RC7Sjhx4tSYfPP" target="_blank" rel="noreferrer">Write Elegant Code</a></p><p><a href="https://drive.google.com/drive/u/0/folders/1NFAgCa7aAdRPFsxBy2RC7Sjhx4tSYfPP" target="_blank" rel="noreferrer">Write Cleaner Code</a></p><hr><h3 id="solid-kiss-dry" tabindex="-1">SOLID, KISS &amp; DRY <a class="header-anchor" href="#solid-kiss-dry" aria-label="Permalink to &quot;SOLID, KISS &amp; DRY&quot;">​</a></h3><h4 id="solid" tabindex="-1">SOLID <a class="header-anchor" href="#solid" aria-label="Permalink to &quot;SOLID&quot;">​</a></h4><ul><li><strong>Single responsibility</strong> : <em>Class</em> can only have 1 responsibility. Don&#39;t create <em>classes</em> that are too complicated and do too many things at once.</li></ul><blockquote><p><strong>Example</strong>: an online motorcycle taxi service might create a <code>Shuttle&#39; class to model its business processes. However, it would be better if the class was split into</code>Delivery<code>which is responsible for taking the user to their destination and</code>Pick Up<code>which is responsible for the function of picking up the user from the place of origin so that if there is any optimization in the</code>Pickup<code>process, a function that implements the</code>Delivery&#39; class `` to be relatively safer</p></blockquote><ul><li><strong>Open for extension but closed for modification</strong>: Functions or uses within an entity must be able to be added without having to change the entity&#39;s content (<em>Open Closed</em>)</li></ul><blockquote><p>Example: <code>Truck</code> has a <code>number of ItemVolume</code> function which has a <em>List</em> parameter of items in <code>Truck</code>. The <code>sumVolumeItems</code> function is responsible for calculating the volume of each item and then adding up the total volume. If there is a new item type with a new volume formula, then <code>ItemVolume count</code> must be updated. There should be a <code>calculateVolume</code> implementation on the items so that for any item type, <code>countVolumeItem</code> does not need to be updated as it will simply sum the results of <code>item.calculateVolume()</code></p></blockquote><ul><li><strong>Liskov substitution principle</strong> : An <em>object</em> must be able to be replaced by an <em>object subtype</em> without changing the program output ( <em>Design by Contract</em> )</li></ul><blockquote><p>Example: function <code>between Passengers</code> has parameter <em>Vehicle</em> which has function <code>brake</code>. <em>Liskov Substitution</em> states that all types of <em>vehicles</em> (<code>Odong Odong</code>, <code>Bemo</code>) must apply <code>brakes</code> for the same purpose (reducing speed).</p></blockquote><ul><li><p><strong>Interface separation principle</strong> : A specific and small <em>Interface</em> is better than a large <em>Interface</em> that causes <em>classes</em> to have to implement unnecessary functions.</p></li><li><p><strong>Dependency inversion principle</strong> : Details must depend on the abstraction. There should be no <em>class</em> that depends / <em>depends</em> on a concrete <em>class</em> ( <em>non abstract</em> )</p></li></ul><blockquote><p><strong>Example</strong> : The <code>passenger&#39; function in the</code>Deliver&#39; class may have a <code>Motorcycle</code> parameter/dependency. However, if an online motorcycle taxi service wants to add &#39;Bemo&#39; to its fleet, of course it has to change the contents of &#39;Bemo&#39;. It is recommended that the parameter from <code>between Passengers</code> be changed to <code>Vehicle</code> (<em>abstract</em>) so that you can add fleet types without having to change the related function/class.</p></blockquote><hr><h4 id="kiss-keep-it-simple-and-straightforward" tabindex="-1">KISS (Keep It Simple and Straightforward) <a class="header-anchor" href="#kiss-keep-it-simple-and-straightforward" aria-label="Permalink to &quot;KISS (Keep It Simple and Straightforward)&quot;">​</a></h4><p>The KISS concept states that the code created must be simple and easy to understand without sacrificing the quality of the final code output.</p><p>Several things that must be considered when implementing the KISS concept are:</p><ul><li><em>methods &amp; classes</em> should be kept as simple as possible.</li><li>Avoid complexity in looping and branching conditions (<em>nested/complex loop &amp; conditional</em>)</li><li>Avoid solutions that are too complicated or code that is too short but difficult to read. Don&#39;t sacrifice performance for easy-to-read lines of code. Find a balance between the two.</li></ul><hr><h4 id="dry-don-t-repeat-yourself" tabindex="-1">DRY (Don&#39;t Repeat Yourself) <a class="header-anchor" href="#dry-don-t-repeat-yourself" aria-label="Permalink to &quot;DRY (Don&#39;t Repeat Yourself)&quot;">​</a></h4><p>Emphasizes on eliminating unnecessary code duplication in software development projects. According to this principle, any knowledge or logic must have a single canonical representation in the system.</p><p>Let&#39;s explore the benefits offered by the DRY principle.</p><ul><li><p><strong>Complexity Reduction</strong> First and foremost, this principle reduces code complexity by avoiding unnecessary repetition. This makes the code more readable, clear, and easy for developers to understand. Additionally, it simplifies code maintenance, as modifications and fixes only need to be done in one place, rather than in several parts of the code.</p></li><li><p><strong>Duplicate Code Removal</strong> To avoid code duplication, there are several techniques developers can implement. First, extracting functions or methods allows grouping similar, repetitive blocks of code into reusable functions. This way, the same code can be called in multiple places without needing to rewrite it.</p></li><li><p><strong>Grouping by Function</strong> The use of classes and inheritance can help encapsulate common functions and reuse them in specific subclasses.</p></li><li><p><strong>Code Reuse</strong> Lastly, the use of modules or frameworks can help in reusing code that has already been written and tested by other developers, thereby eliminating the need to start from scratch.</p></li></ul><blockquote><p><strong>Example</strong> : Suppose we are developing a contact management application with features for adding, changing, and deleting contacts. Rather than repeating the same data validation code in several places in the program, we can extract this validation logic into a separate function or utility class. This way, every time we need to validate contact data, we simply call that function or utility class, avoiding code duplication.</p></blockquote><p>By applying DRY principles, we reduce complexity, increase maintainability, and encourage code reuse, resulting in more efficient development and more robust systems.</p><hr><h4 id="yagni-you-ain-t-gonna-need-it" tabindex="-1">YAGNI (You Ain’t Gonna Need It) <a class="header-anchor" href="#yagni-you-ain-t-gonna-need-it" aria-label="Permalink to &quot;YAGNI (You Ain’t Gonna Need It)&quot;">​</a></h4><p>The YAGNI (You Ain&#39;t Gonna Need It) principle emphasizes not implementing features or code that are not immediately needed. According to this principle, it is better to focus on the features that matter and avoid anticipating hypothetical future needs.</p><ul><li><strong>Convention over Configuration</strong> (CoC) The Convention over Configuration (CoC) principle encourages the use of pre-defined conventions, rather than explicit configurations.</li></ul><p>-<strong>Composition over Inheritance</strong> The Composition over Inheritance principle advocates using class composition instead of inheritance to encourage code reuse and avoid rigid dependencies between classes or building complex objects by combining simpler objects rather than creating complex inheritance hierarchies.</p><p>-<strong>Law of Demeter (LoD/Principle of Only Talking to Your Closest Friends)</strong> Software design principles that encourage separation and reduce dependencies between classes.</p><p>Read more:</p><p><a href="https://drive.google.com/drive/u/0/folders/1NFAgCa7aAdRPFsxBy2RC7Sjhx4tSYfPP" target="_blank" rel="noreferrer">SOLID : Object Oriented Design</a></p><p><a href="https://drive.google.com/drive/u/0/folders/1NFAgCa7aAdRPFsxBy2RC7Sjhx4tSYfPP" target="_blank" rel="noreferrer">SOLID, GRASP and other principles of OOP</a></p><hr><h4 id="unit-test-test-driven-development" tabindex="-1">Unit Test (Test Driven Development) <a class="header-anchor" href="#unit-test-test-driven-development" aria-label="Permalink to &quot;Unit Test (Test Driven Development)&quot;">​</a></h4><ul><li><strong>The Three Laws of TDD</strong> By now everyone knows that TDD requires us to write unit tests first before writing production code. However, these regulations are just the tip of the iceberg. Pay attention to the following three laws: First Law You should not write production code until you have written unit tests that fail. Second Law You should never write more than enough unit tests to fail, and don&#39;t failed to stack. Third Law You should never write more than enough production code to pass a test that is currently failing.</li><li><strong>FIRST.</strong> A clean test follows the five other rules that make up the acronym above:</li></ul><blockquote><p><strong>Fast</strong> Tests must be fast. Tests should run quickly. If a test is slow, you won&#39;t run it often. If you don&#39;t run it often, you won&#39;t catch problems early enough to fix them easily. You won&#39;t feel free to clean up the code. Eventually the code will start to rot.</p></blockquote><blockquote><p><strong>Independent</strong> Tests should not depend on each other. One test does not necessarily determine the conditions for the next test. You should be able to run each test independently and run the tests in any order you want. When tests depend on each other, failure on the first test will lead to a series of failures on subsequent tests, complicating diagnosis and hiding defects in subsequent tests.</p></blockquote><blockquote><p><strong>Repeatable</strong> Tests must be repeatable in any environment. You should be able to run tests in a production environment, in a QA environment, and on your laptop on the way home without a network. If your tests are not repeatable in any environment, you will always have a reason why they failed. You will also find yourself unable to run tests when the environment is not available.</p></blockquote><blockquote><p><strong>Self Validation</strong> Tests must have a boolean output. Either they pass or fail. You You don&#39;t need to read the log file to know whether the test passed or not. You don&#39;t need to manually compare two different text files to find out whether the test passes or not. If the test is not self-validating, then failure can be subjective and running the test requires lengthy manual evaluation.</p></blockquote><blockquote><p><strong>Timely</strong> Tests must be written on time. Unit tests should be written right before the production code that makes them pass. If you write tests after production code, you may find the production code difficult to test. You may decide that some production code is too difficult to test. You probably didn&#39;t design your production code to be testable.</p></blockquote><hr><h3 id="oop-concept" tabindex="-1">OOP concept <a class="header-anchor" href="#oop-concept" aria-label="Permalink to &quot;OOP concept&quot;">​</a></h3><p>Some of the main concepts that must be understood from the OOP (<em>Object Oriented Programming</em>) paradigm are:</p><p><strong>Everything is an object</strong></p><p>Many people say that in OOP, everything can be represented as an <code>Object</code>. It may or may not be applied in certain situations/concepts ( <em>primitive variables</em>, <em>methods</em>, etc). However, it needs to be understood that in solution modeling, almost all problems and solutions can be represented as a collection of interacting objects. Therefore, the ability to model problems into objects and their representation is very important in understanding OOP.</p><p><strong>Encapsulation</strong></p><p>Encapsulation states that the internal implementation/representation of an object must not be visible from other objects.</p><p>Encapsulation can be done by restricting access to <em>accessors</em> and <em>mutators</em>. <em><strong>Accessor</strong></em> is a function that can provide values ​​contained in an object. <em><strong>Mutator</strong></em> is a function that can change the internal representation/value contained in an object.</p><blockquote><p><strong>Example</strong>: a <code>Person</code> object can have an <em>Accessor</em> <code>getClothes()</code> and a <em>Mutator</em> <code>setClothes(...)</code> to find out and change the clothes it is wearing</p></blockquote><p><strong>Abstraction</strong></p><p>Abstraction is closely related to encapsulation, because basically abstraction is the process of creating an object that has no real implementation in its <em>Accessor</em> or <em>Mutator</em>. This implementation will be applied to the object that represents it</p><blockquote><p><strong>Example</strong>: a <code>Human</code> object has a <code>canRead</code> <em>Accessor</em>, but the implementation of <code>canRead</code> will differ depending on what other objects represent <code>Human</code>. Budi may <code>can read</code> (return <code>true</code>) but Joko may not <code>can read</code> (return <code>false</code>)</p></blockquote><p><strong>Inheritance</strong></p><p>In general, objects can interact with each other in the relationships of have (<em>has a</em>), use (<em>uses a</em>), or represent (<em>is a</em>). <em>Is a</em> or representation a form of <em>Interitance</em> or inheritance. In the concept of <em>Inheritance</em> there are the terms <em>parent/super class</em> and <em>child class</em>. <em>Derived classes</em> will inherit non-private properties and functions owned by the <em>parent/super class</em>.</p><blockquote><p><strong>Example</strong> : The <code>Vehicle</code> class has a <code>wheel</code> property and a <code>setSpeed</code> function. All classes that are <em>derived classes</em> from <code>Vehicle</code> will have <code>wheel</code> and <code>setSpeed</code> functions automatically.</p></blockquote><p><strong>Polymorphism</strong></p><p><em>Polymorphism</em> can be described or interpreted as an operation that has several types of implementation</p><p>Some types of <em>Polymorphism</em> are:</p><ul><li><em>Ad Hoc Polymorphism</em> or <em>Function Overloading</em> is a function that has the same name, but different parameters so it can have different implementations</li></ul><blockquote><p>Example: a function with <code>sum</code> can have parameters <code>Arabic numerals (1-0)</code> or <code>Roman numerals (I-X)</code> so the implementation of <code>sum(10, 20)</code> will of course be different from <code>sum(XV, IV )</code></p></blockquote><ul><li><em>Parametric Polymorphism</em> or <em>Generic Type</em> is a function or data type that is written generally so that it can accommodate all types of data types without exception</li></ul><blockquote><p>Example: class <code>Drink&lt;T&gt;</code> and function <code>mixDrink(T)</code> have a <em>Generic Type</em> represented in <code>T</code>. In the process of representing <code>Drinks</code>, <code>T</code> can be defined as any data type (e.g. <code>Coffee</code> or <code>Tea</code>) and <code>racikDrinks</code> must use the same data type as a parameter (being <code>racikDrinks(Coffee)</code> or <code>RasikDrinks ( Tea)</code>.</p></blockquote><ul><li><em>Subtyping</em> or <em>Function Overriding</em> is a function that is inherited from a <em>parent class</em> but can be defined differently by a <em>child class</em></li></ul><blockquote><p>Example: the class <code>Animal</code> has a <code>talk</code> function, but the class representing <code>Animal</code> may have a different way of <code>talk</code> (e.g. <code>Cat</code> <code>talk</code> will return <em>Meow!</em> and <code>Dog</code> <code>talk</code> will back <em>Woof!</em> )</p></blockquote><p>Read more:</p><p><a href="https://www.udemy.com/draft/725258/learn/v4/content" target="_blank" rel="noreferrer">Design Pattern Guide</a></p><p><a href="https://en.wikipedia.org/wiki/Object-oriented_programming" target="_blank" rel="noreferrer">OOP on Wikipedia</a></p><hr><h3 id="konsep-reactive-programming" tabindex="-1">Konsep Reactive Programming <a class="header-anchor" href="#konsep-reactive-programming" aria-label="Permalink to &quot;Konsep Reactive Programming&quot;">​</a></h3><p>Some of the main concepts that must be understood from the <em>Reactive Programming</em> paradigm are:</p><p><strong>Everything is a flow</strong></p><p>Slightly different from the OOP concept which describes problems and solutions as objects and their interactions, <em>Reactive Programming</em> focuses on events and event flows (<em>flow &amp; events</em>). Most processes can be described in terms of a collection of events (<em>event</em>) and a flow of events from start to finish (<em>flow</em>)</p><p>Because of this difference in paradigm, <em>Reactive Programming</em> is very suitable when applied to systems that require instant / <em>real time</em> responses because this paradigm is very focused on events (<em>event</em>) and reactions (<em>response</em>).</p><p><strong>Subject / Observable</strong></p><p><em>Stream</em> can be implemented by initializing <em>Subject</em> (can also be called <em>Observable</em>). <em>Observable</em> is an object/data that can be monitored (<em>observed/subscribed</em>) by the <em>Observer</em>. Any changes in data status will be immediately informed to all <em>Observers</em> who monitor <em>Observable</em> data.</p><p><strong>Observer</strong></p><p><em>Observer</em> is an object/data that monitors all changes to <em>Subject/Observable</em> values. After the <em>Observer</em> declares itself ready to monitor (<em>subscribe</em>) the <em>Observable</em>, the <em>Observer</em> has entered the <em>data flow</em> which is currently in process. Every time there is a change in the internal status of the <em>Subject/Observable</em>, the <em>Observer</em> will receive a notification so that it can react according to its actions.</p><p>Read more:</p><p><a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" target="_blank" rel="noreferrer">Reactive Programming Introduction</a></p><p><a href="http://reactivex.io/" target="_blank" rel="noreferrer">ReactiveX</a></p><hr>',102)]))}const u=t(i,[["render",s]]);export{h as __pageData,u as default};
